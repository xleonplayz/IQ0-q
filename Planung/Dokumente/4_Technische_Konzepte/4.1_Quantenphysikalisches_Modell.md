# Quantenphysikalisches Modell

## Dokumentinformationen
| Aspekt | Details |
|--------|---------|
| Dokumentversion | 0.1 |
| Datum | 29.04.2025 |
| Status | Entwurf |
| Verantwortlich | Projektteam |

## Zweck und Umfang
Dieses Dokument beschreibt das quantenphysikalische Modell, das im NV-Center Simulator implementiert wird. Es erläutert die theoretischen Grundlagen, die Implementierungsdetails und die Integration mit der SimOS-Bibliothek. Das Modell bildet die Grundlage für die realistische Simulation des Verhaltens von NV-Zentren unter verschiedenen experimentellen Bedingungen.

## Grundlagen des NV-Zentrums

### Struktur und Energieniveaus
Das Stickstoff-Fehlstellen-Zentrum (NV-Zentrum) in Diamant ist ein Punktdefekt, der aus einem Stickstoffatom und einer benachbarten Fehlstelle im Diamantgitter besteht. Es existiert in zwei Ladungszuständen, NV⁰ und NV⁻, wobei für Quantenexperimente hauptsächlich der negativ geladene Zustand NV⁻ relevant ist.

Die Energieniveaus des NV⁻-Zentrums umfassen:

1. **Grundzustand (³A₂)**: Ein Triplett-Zustand mit Spin S=1
   - m_s = 0: Energetisch bevorzugter Zustand bei Nullfeld
   - m_s = ±1: Entartete Zustände, die durch Magnetfelder aufgespalten werden können

2. **Angeregter Zustand (³E)**: Ein Triplett-Zustand
   - Optischer Übergang vom Grundzustand (Anregungswellenlänge 532 nm)
   - Fluoreszenzemission (637-800 nm)

3. **Metastabile Singulett-Zustände (¹A₁, ¹E)**:
   - Ermöglichen spinabhängige Fluoreszenzdetektion durch unterschiedliche Übergangsraten

### Hamiltonian des NV-Zentrums
Der Spin-Hamiltonian des NV-Zentrums im Grundzustand in einem externen Magnetfeld ist:

```
H = D[S_z^2 - S(S+1)/3] + E(S_x^2 - S_y^2) + γₑ B·S + S·A·I
```

wobei:
- D ≈ 2.87 GHz ist die Nullfeldaufspaltung
- E ist der Strain-Parameter (typischerweise < 10 MHz)
- γₑ ist das gyromagnetische Verhältnis des Elektronenspins
- B ist das externe Magnetfeld
- S ist der Elektronenspin-Operator (S=1)
- A ist der Hyperfein-Tensor
- I ist der Kernspin-Operator (für 14N: I=1, für 15N: I=1/2)

## SimOS-Integration

### SimOS-Übersicht
SimOS (Simulation of Optically addressable Spins) ist eine Python-Bibliothek zur Simulation von optisch adressierbaren Spinsystemen, einschließlich NV-Zentren. Sie bietet:

- Datenstrukturen für Quantenzustände und Operatoren
- Funktionen zur Zeitentwicklung quantenmechanischer Systeme
- Vordefinierte Modelle für NV-Zentren und andere Spinsysteme
- Mathematische Werkzeuge für kohärente und inkohärente Quantendynamik

### Integration in den Simulator
Die SimOS-Bibliothek wird als Kernkomponente des quantenphysikalischen Modells verwendet. Die Integration erfolgt durch:

1. Verwendung der SimOS-Klassen für Zustandsrepräsentation und -manipulation
2. Erweiterung der SimOS-Funktionalität für spezifische Simulationsanforderungen
3. Anpassung der SimOS-Parameter an experimentelle Bedingungen
4. Entwicklung von Adapter-Klassen zur Verbindung mit den Qudi-Interfaces

## Implementierung des Quantenmodells

### Hauptkomponenten des Modells

```python
class PhysicalNVModel:
    """
    Implementierung des quantenphysikalischen Modells für NV-Zentren.
    Basiert auf der SimOS-Bibliothek und erweitert diese für die
    spezifischen Anforderungen des Simulators.
    """
    
    def __init__(self, config=None):
        """
        Initialisiert das NV-Modell mit den angegebenen Konfigurationsparametern.
        
        Args:
            config (dict, optional): Konfigurationsparameter für das Modell.
                                     Wenn None, werden Standardwerte verwendet.
        """
        self.config = config or self._default_config()
        
        # Initialisierung des NV-Systems mit SimOS
        self.nv_system = self._initialize_nv_system()
        
        # Aktueller Zustand des NV-Zentrums
        self.current_state = self._initial_state()
        
        # Aktuelles Magnetfeld
        self.magnetic_field = np.array([0.0, 0.0, 0.0])
        
        # Mikrowellenparameter
        self.mw_frequency = 2.87e9  # Hz
        self.mw_power = 0.0  # dBm
        self.mw_on = False
        
        # Laserparameter
        self.laser_power = 0.0  # mW
        self.laser_on = False
        
        # Lock für Thread-Sicherheit
        self.lock = threading.RLock()
        
        # Simulationszeitschritt
        self.dt = 1e-9  # 1 ns
        
        # Simulationsthread
        self.simulation_thread = None
        self.stop_simulation = threading.Event()
    
    def _default_config(self):
        """Liefert die Standardkonfiguration für das NV-Modell."""
        return {
            # NV-Zentrum-Parameter
            'zero_field_splitting': 2.87e9,  # Hz
            'strain': 5e6,  # Hz
            'gyromagnetic_ratio': 2.8025e10,  # Hz/T
            
            # Relaxationszeiten
            'T1': 1e-3,  # s
            'T2': 1e-6,  # s
            
            # Optische Eigenschaften
            'fluorescence_contrast': 0.3,
            'optical_readout_fidelity': 0.93,
            
            # Umgebungsparameter
            'temperature': 300,  # K
            
            # Hyperfein-Parameter (14N)
            'hyperfine_coupling_14n': 2.14e6,  # Hz
            'quadrupole_splitting_14n': -4.96e6,  # Hz
            
            # Simulationsparameter
            'simulation_timestep': 1e-9,  # s
            'use_gpu': False
        }
    
    def _initialize_nv_system(self):
        """Initialisiert das NV-System mit SimOS."""
        from simos.systems import NV
        
        # Erstellen eines NV-Systems mit den konfigurierten Parametern
        nv = NV.create_hamiltonian(
            d=self.config['zero_field_splitting'],
            e=self.config['strain'],
            include_hyperfine=True
        )
        return nv
    
    def _initial_state(self):
        """Erstellt den initialen Quantenzustand des NV-Zentrums."""
        from simos.states import SpinState
        
        # Initialisierung im m_s = 0 Zustand
        return SpinState.ms0(self.nv_system)
    
    def set_magnetic_field(self, field_vector):
        """
        Setzt das externe Magnetfeld.
        
        Args:
            field_vector (numpy.ndarray): 3D-Vektor des Magnetfelds in [Bx, By, Bz] in Tesla.
        """
        with self.lock:
            self.magnetic_field = np.array(field_vector)
            
            # Aktualisieren des Hamiltonians
            from simos.core import zeeman_term
            zeeman = zeeman_term(
                self.nv_system, 
                self.config['gyromagnetic_ratio'] * self.magnetic_field
            )
            self.nv_system.hamiltonian = self.nv_system.hamiltonian + zeeman
    
    def apply_microwave(self, frequency, power, on=True):
        """
        Wendet eine Mikrowellenanregung auf das NV-Zentrum an.
        
        Args:
            frequency (float): Mikrowellenfrequenz in Hz.
            power (float): Mikrowellenleistung in dBm.
            on (bool): Ob die Mikrowelle ein- oder ausgeschaltet ist.
        """
        with self.lock:
            self.mw_frequency = frequency
            self.mw_power = power
            self.mw_on = on
    
    def apply_laser(self, power, on=True):
        """
        Wendet eine Laseranregung auf das NV-Zentrum an.
        
        Args:
            power (float): Laserleistung in mW.
            on (bool): Ob der Laser ein- oder ausgeschaltet ist.
        """
        with self.lock:
            self.laser_power = power
            self.laser_on = on
    
    def evolve_state(self, duration):
        """
        Entwickelt den Quantenzustand für die angegebene Dauer.
        
        Args:
            duration (float): Entwicklungsdauer in Sekunden.
            
        Returns:
            dict: Ergebnisse der Entwicklung, einschließlich Endzustand und Messungen.
        """
        with self.lock:
            from simos.propagation import liouville_evolution
            
            # Erstellen des vollständigen Hamiltonians einschließlich Mikrowellen
            hamiltonian = self._create_current_hamiltonian()
            
            # Einbeziehen von Relaxation
            lindblad_ops = self._create_lindblad_operators()
            
            # Zeitentwicklung mit dem Liouville-Formalismus
            rho_final = liouville_evolution(
                self.current_state.to_density_matrix(),
                hamiltonian,
                lindblad_ops,
                duration
            )
            
            # Aktualisieren des aktuellen Zustands
            self.current_state.from_density_matrix(rho_final)
            
            # Fluoreszenzberechnung basierend auf dem aktuellen Zustand
            fluorescence = self._calculate_fluorescence()
            
            return {
                'state': self.current_state,
                'fluorescence': fluorescence,
                'populations': self._calculate_populations()
            }
    
    def _create_current_hamiltonian(self):
        """Erstellt den aktuellen Hamiltonian basierend auf allen angewandten Feldern."""
        # Basishamiltonian mit Magnetfeld
        hamiltonian = self.nv_system.hamiltonian
        
        # Hinzufügen der Mikrowellenanregung, wenn eingeschaltet
        if self.mw_on:
            from simos.core import microwave_drive
            
            # Umrechnung der dBm in Feldstärke
            mw_amplitude = self._dbm_to_field(self.mw_power)
            
            # Erstellen des Mikrowellenterms (transversales Feld)
            mw_term = microwave_drive(
                self.nv_system,
                amplitude=mw_amplitude,
                frequency=self.mw_frequency,
                phase=0.0
            )
            
            hamiltonian = hamiltonian + mw_term
        
        return hamiltonian
    
    def _create_lindblad_operators(self):
        """Erstellt Lindblad-Operatoren für inkohärente Prozesse."""
        lindblad_ops = []
        
        # T1-Relaxation
        if self.config['T1'] > 0:
            from simos.incoherent import relaxation
            t1_ops = relaxation(self.nv_system, rate=1/self.config['T1'])
            lindblad_ops.extend(t1_ops)
        
        # T2-Dekohärenz
        if self.config['T2'] > 0:
            from simos.incoherent import dephasing
            t2_ops = dephasing(self.nv_system, rate=1/self.config['T2'])
            lindblad_ops.extend(t2_ops)
        
        # Optische Anregung und Emission (wenn Laser eingeschaltet)
        if self.laser_on and self.laser_power > 0:
            from simos.incoherent import optical_cycle
            laser_rate = self._calculate_laser_excitation_rate()
            optical_ops = optical_cycle(
                self.nv_system, 
                excitation_rate=laser_rate,
                contrast=self.config['fluorescence_contrast']
            )
            lindblad_ops.extend(optical_ops)
        
        return lindblad_ops
    
    def _calculate_laser_excitation_rate(self):
        """Berechnet die optische Anregungsrate basierend auf der Laserleistung."""
        # Einfaches Modell: lineare Beziehung mit Sättigung
        max_rate = 1e7  # Hz, Sättigungsrate
        power_saturation = 5.0  # mW, Sättigungsleistung
        
        rate = max_rate * self.laser_power / (self.laser_power + power_saturation)
        return rate
    
    def _calculate_fluorescence(self):
        """Berechnet die Fluoreszenzintensität basierend auf dem aktuellen Zustand."""
        if not self.laser_on or self.laser_power <= 0:
            return 0.0
        
        # Berechnung der Besetzungswahrscheinlichkeiten
        populations = self._calculate_populations()
        
        # NV-Fluoreszenz hängt vom Spinzustand ab
        # m_s = 0 hat höhere Fluoreszenz als m_s = ±1
        base_fluorescence = self._calculate_laser_excitation_rate() * 0.1  # Grundfluoreszenz
        
        # Fluoreszenzkontrast zwischen m_s = 0 und m_s = ±1
        contrast = self.config['fluorescence_contrast']
        
        # Berechnung der Gesamtfluoreszenz
        fluorescence = base_fluorescence * (
            populations['ms0'] + 
            (1 - contrast) * (populations['ms+1'] + populations['ms-1'])
        )
        
        # Füge realistisches Rauschen hinzu (Poisson-Rauschen für Photonenzählung)
        noise_amplitude = np.sqrt(fluorescence)
        noise = np.random.normal(0, noise_amplitude)
        
        return max(0, fluorescence + noise)
    
    def _calculate_populations(self):
        """Berechnet die Besetzungswahrscheinlichkeiten der verschiedenen Spinzustände."""
        from simos.core import spin_projection
        
        # Dichtematrix des aktuellen Zustands
        rho = self.current_state.to_density_matrix()
        
        # Projektionsoperatoren für die verschiedenen m_s-Zustände
        ms0_proj = spin_projection(self.nv_system, ms=0)
        msplus_proj = spin_projection(self.nv_system, ms=1)
        msminus_proj = spin_projection(self.nv_system, ms=-1)
        
        # Berechnung der Erwartungswerte
        ms0_pop = np.real(np.trace(np.dot(ms0_proj, rho)))
        msplus_pop = np.real(np.trace(np.dot(msplus_proj, rho)))
        msminus_pop = np.real(np.trace(np.dot(msminus_proj, rho)))
        
        return {
            'ms0': ms0_pop,
            'ms+1': msplus_pop,
            'ms-1': msminus_pop
        }
    
    def _dbm_to_field(self, power_dbm):
        """Wandelt Mikrowellenleistung in dBm in Feldstärke um."""
        # Einfache Näherung: 0 dBm entspricht etwa 1 MHz Rabi-Frequenz
        power_mw = 10**(power_dbm/10)  # Umrechnung in mW
        
        # Lineare Näherung zwischen Leistung und Feldamplitude
        field_amplitude = np.sqrt(power_mw) * 1e6  # Hz
        
        return field_amplitude
    
    def start_continuous_simulation(self):
        """Startet einen kontinuierlichen Simulationsthread."""
        if self.simulation_thread is not None and self.simulation_thread.is_alive():
            return
        
        self.stop_simulation.clear()
        self.simulation_thread = threading.Thread(
            target=self._simulation_loop, 
            daemon=True
        )
        self.simulation_thread.start()
    
    def stop_continuous_simulation(self):
        """Stoppt den kontinuierlichen Simulationsthread."""
        if self.simulation_thread is None:
            return
            
        self.stop_simulation.set()
        self.simulation_thread.join(timeout=1.0)
        self.simulation_thread = None
    
    def _simulation_loop(self):
        """Kontinuierliche Simulationsschleife."""
        while not self.stop_simulation.is_set():
            # Entwicklung für einen einzelnen Zeitschritt
            self.evolve_state(self.dt)
            
            # Kurze Pause, um CPU-Last zu reduzieren
            time.sleep(self.dt * 0.1)  # 10% der Simulationszeit
    
    def reset_state(self):
        """Setzt den Quantenzustand auf den Initialzustand zurück."""
        with self.lock:
            self.current_state = self._initial_state()
            self.mw_on = False
            self.laser_on = False
    
    def perform_odmr_scan(self, start_freq, stop_freq, steps, power_dbm, duration_per_point):
        """
        Führt einen ODMR-Scan durch.
        
        Args:
            start_freq (float): Startfrequenz in Hz
            stop_freq (float): Endfrequenz in Hz
            steps (int): Anzahl der Messpunkte
            power_dbm (float): Mikrowellenleistung in dBm
            duration_per_point (float): Messdauer pro Punkt in Sekunden
            
        Returns:
            dict: Ergebnisse des ODMR-Scans
        """
        frequencies = np.linspace(start_freq, stop_freq, steps)
        fluorescence = np.zeros(steps)
        
        # Laser einschalten für den gesamten Scan
        self.apply_laser(power=1.0, on=True)
        
        for i, freq in enumerate(frequencies):
            # Mikrowelle auf aktuelle Frequenz einstellen
            self.apply_microwave(frequency=freq, power=power_dbm, on=True)
            
            # System für die angegebene Dauer entwickeln
            result = self.evolve_state(duration_per_point)
            
            # Fluoreszenz speichern
            fluorescence[i] = result['fluorescence']
            
            # Kurze Pause für realistisches Verhalten
            time.sleep(0.001)
        
        # Mikrowelle ausschalten
        self.apply_microwave(frequency=frequencies[-1], power=power_dbm, on=False)
        
        return {
            'frequencies': frequencies,
            'fluorescence': fluorescence
        }
    
    def perform_rabi_measurement(self, frequency, power_dbm, max_duration, steps):
        """
        Führt eine Rabi-Oszillationsmessung durch.
        
        Args:
            frequency (float): Mikrowellenfrequenz in Hz
            power_dbm (float): Mikrowellenleistung in dBm
            max_duration (float): Maximale Pulsdauer in Sekunden
            steps (int): Anzahl der Messpunkte
            
        Returns:
            dict: Ergebnisse der Rabi-Messung
        """
        durations = np.linspace(0, max_duration, steps)
        fluorescence = np.zeros(steps)
        
        # System in den Grundzustand initialisieren
        self.reset_state()
        
        for i, duration in enumerate(durations):
            # System in m_s = 0 initialisieren (Laserinitialisierung)
            self.apply_laser(power=1.0, on=True)
            self.evolve_state(duration=1e-6)  # 1 µs Laseranregung
            self.apply_laser(power=0.0, on=False)
            
            # Mikrowellenpuls anwenden
            self.apply_microwave(frequency=frequency, power=power_dbm, on=True)
            self.evolve_state(duration=duration)
            self.apply_microwave(frequency=frequency, power=power_dbm, on=False)
            
            # Auslesen mit Laser
            self.apply_laser(power=1.0, on=True)
            result = self.evolve_state(duration=1e-6)  # 1 µs Auslesepuls
            self.apply_laser(power=0.0, on=False)
            
            # Fluoreszenz speichern
            fluorescence[i] = result['fluorescence']
            
            # Kurze Pause für realistisches Verhalten
            time.sleep(0.001)
        
        return {
            'durations': durations,
            'fluorescence': fluorescence
        }
```

### Schlüsselfunktionalitäten

1. **Quantenzustandsrepräsentation**:
   - Verwendung von SimOS-Datenstrukturen für Spins und Zustände
   - Unterstützung für Reinzustände und gemischte Zustände (Dichtematrizen)
   - Effiziente Berechnung von Erwartungswerten und Observablen

2. **Zeitentwicklung**:
   - Kohärente Entwicklung durch numerische Integration der Schrödingergleichung
   - Inkohärente Entwicklung durch Lindblad-Mastergleichung
   - Verschiedene Zeitskalen für unterschiedliche physikalische Prozesse

3. **Physikalische Prozesse**:
   - Zeeman-Effekt durch externe Magnetfelder
   - Mikrowellenanregung mit variabler Frequenz und Amplitude
   - Optische Übergänge und spinabhängige Fluoreszenz
   - T1- und T2-Relaxationsprozesse

4. **Experimentelle Protokolle**:
   - ODMR-Messungen (Optically Detected Magnetic Resonance)
   - Rabi-Oszillationen
   - Ramsey-Interferometrie
   - Spin-Echo-Experimente
   - Pulsed-ODMR

## Validierung und Kalibrierung

### Validierungsstrategie
Die Genauigkeit des quantenphysikalischen Modells wird durch folgende Methoden validiert:

1. **Vergleich mit analytischen Lösungen**:
   - Rabi-Oszillationen in resonanten Zweizustandssystemen
   - Larmorpräzession in statischen Magnetfeldern
   - Zeeman-Aufspaltung bei verschiedenen Magnetfeldstärken

2. **Vergleich mit experimentellen Daten**:
   - ODMR-Spektren von realen NV-Zentren
   - Rabi-Oszillationsmessungen
   - T1- und T2-Relaxationskurven

3. **Kreuzvalidierung mit anderen Simulationstools**:
   - QuTiP-basierte Simulationen
   - Veröffentlichte Simulationsergebnisse aus der Literatur

### Kalibrierungsverfahren
Das Modell wird anhand experimenteller Daten kalibriert, um realistische Simulationen zu gewährleisten:

1. **Parameteranpassung**:
   - Nullfeldaufspaltung D
   - Strain-Parameter E
   - Hyperfeinwechselwirkungskonstanten
   - Relaxationszeiten T1 und T2
   - Fluoreszenzkontrast

2. **Experimentelle Kalibrierungsprotokolle**:
   - ODMR-Messungen bei verschiedenen Magnetfeldstärken
   - Rabi-Oszillationen bei verschiedenen Mikrowellenleistungen
   - T1- und T2-Messungen für Relaxationszeiten

## Leistungsoptimierung

### Numerische Effizienz
Die Simulation quantenmechanischer Systeme kann rechenintensiv sein. Folgende Optimierungen werden implementiert:

1. **Vektorisierung**:
   - Verwendung von NumPy für effiziente Array-Operationen
   - Vermeidung von Python-Schleifen für kritische Berechnungen

2. **Sparse-Matrix-Darstellung**:
   - Verwendung von dünn besetzten Matrizen für große Hilberträume
   - Effiziente Algorithmen für Matrixexponentiation

3. **Adaptive Zeitschritte**:
   - Anpassung der Zeitschritte basierend auf der Systemdynamik
   - Größere Schritte für langsame Prozesse, kleinere für schnelle

### Parallelisierung
Für rechenintensive Simulationen werden Parallelisierungsstrategien verwendet:

1. **Multiprocessing**:
   - Parallele Berechnung unabhängiger Simulationsschritte
   - Verteilung von Parameter-Sweeps auf mehrere CPU-Kerne

2. **GPU-Beschleunigung (optional)**:
   - CuPy oder TensorFlow für GPU-beschleunigte Berechnungen
   - Besonders effektiv für große Hilberträume und komplexe Dynamik

## Integration mit dem Simulator

### Schnittstelle zum QuantumSimulatorState
Der `PhysicalNVModel` wird in die zentrale `QuantumSimulatorState`-Klasse integriert, die als Schnittstelle zu den Qudi-Hardware-Interfaces dient:

```python
class QuantumSimulatorState:
    """
    Zentraler Zustandsmanager für den NV-Center Simulator.
    Implementiert als Thread-sicherer Singleton.
    """
    _instance = None
    _lock = threading.RLock()
    
    def __new__(cls, *args, **kwargs):
        """Implementierung des Singleton-Musters."""
        with cls._lock:
            if cls._instance is None:
                cls._instance = super(QuantumSimulatorState, cls).__new__(cls)
                cls._instance._initialized = False
            return cls._instance
    
    def __init__(self, config=None):
        """Initialisierung des Simulatorzustands."""
        with self._lock:
            if self._initialized:
                return
                
            self.config = config or {}
            
            # Quantenphysikalisches Modell
            self.physical_model = PhysicalNVModel(config)
            
            # Status der verschiedenen Hardware-Komponenten
            self.microwave_status = {
                'frequency': 2.87e9,  # Hz
                'power': -20.0,  # dBm
                'on': False
            }
            
            self.laser_status = {
                'power': 0.0,  # mW
                'on': False
            }
            
            self.counter_status = {
                'samples': 0,
                'running': False,
                'data': []
            }
            
            # Event-Handling
            self.event_callbacks = {
                'microwave_changed': [],
                'laser_changed': [],
                'counter_changed': [],
                'state_changed': []
            }
            
            self._initialized = True
    
    def set_microwave_params(self, frequency=None, power=None, on=None):
        """Setzt Mikrowellenparameter und aktualisiert das physikalische Modell."""
        with self._lock:
            # Aktualisieren nur der angegebenen Parameter
            if frequency is not None:
                self.microwave_status['frequency'] = frequency
            if power is not None:
                self.microwave_status['power'] = power
            if on is not None:
                self.microwave_status['on'] = on
            
            # Aktualisieren des physikalischen Modells
            self.physical_model.apply_microwave(
                frequency=self.microwave_status['frequency'],
                power=self.microwave_status['power'],
                on=self.microwave_status['on']
            )
            
            # Benachrichtigung über Änderungen
            self._notify_event('microwave_changed')
    
    def set_laser_params(self, power=None, on=None):
        """Setzt Laserparameter und aktualisiert das physikalische Modell."""
        with self._lock:
            # Aktualisieren nur der angegebenen Parameter
            if power is not None:
                self.laser_status['power'] = power
            if on is not None:
                self.laser_status['on'] = on
            
            # Aktualisieren des physikalischen Modells
            self.physical_model.apply_laser(
                power=self.laser_status['power'],
                on=self.laser_status['on']
            )
            
            # Benachrichtigung über Änderungen
            self._notify_event('laser_changed')
    
    def set_magnetic_field(self, field_vector):
        """Setzt das externe Magnetfeld."""
        with self._lock:
            self.physical_model.set_magnetic_field(field_vector)
            self._notify_event('state_changed')
    
    def get_fluorescence(self):
        """Ruft die aktuelle Fluoreszenzintensität ab."""
        with self._lock:
            result = self.physical_model.evolve_state(duration=1e-6)  # Kurze Entwicklung
            return result['fluorescence']
    
    def perform_odmr_scan(self, start_freq, stop_freq, steps, power_dbm, duration_per_point):
        """Führt einen ODMR-Scan durch."""
        with self._lock:
            return self.physical_model.perform_odmr_scan(
                start_freq, stop_freq, steps, power_dbm, duration_per_point
            )
    
    def perform_rabi_measurement(self, frequency, power_dbm, max_duration, steps):
        """Führt eine Rabi-Messung durch."""
        with self._lock:
            return self.physical_model.perform_rabi_measurement(
                frequency, power_dbm, max_duration, steps
            )
    
    def start_continuous_counting(self):
        """Startet kontinuierliches Photonenzählen."""
        with self._lock:
            if self.counter_status['running']:
                return
                
            self.counter_status['running'] = True
            self.counter_status['data'] = []
            
            # Starten der kontinuierlichen Simulation
            self.physical_model.start_continuous_simulation()
            
            # Starten eines separaten Threads zum Sammeln von Zähldaten
            self._start_counter_thread()
            
            self._notify_event('counter_changed')
    
    def stop_continuous_counting(self):
        """Stoppt kontinuierliches Photonenzählen."""
        with self._lock:
            if not self.counter_status['running']:
                return
                
            self.counter_status['running'] = False
            
            # Stoppen der kontinuierlichen Simulation
            self.physical_model.stop_continuous_simulation()
            
            self._notify_event('counter_changed')
    
    def _start_counter_thread(self):
        """Startet einen Thread zum Sammeln von Photonenzählungen."""
        def counter_loop():
            while self.counter_status['running']:
                with self._lock:
                    fluorescence = self.get_fluorescence()
                    self.counter_status['data'].append(fluorescence)
                    self.counter_status['samples'] += 1
                
                # Kurze Pause, um CPU-Last zu reduzieren
                time.sleep(0.01)  # 10 ms
        
        thread = threading.Thread(target=counter_loop, daemon=True)
        thread.start()
    
    def register_callback(self, event_type, callback):
        """Registriert einen Callback für Ereignisse."""
        with self._lock:
            if event_type in self.event_callbacks:
                self.event_callbacks[event_type].append(callback)
    
    def unregister_callback(self, event_type, callback):
        """Entfernt einen registrierten Callback."""
        with self._lock:
            if event_type in self.event_callbacks:
                if callback in self.event_callbacks[event_type]:
                    self.event_callbacks[event_type].remove(callback)
    
    def _notify_event(self, event_type):
        """Benachrichtigt alle registrierten Callbacks über ein Ereignis."""
        if event_type in self.event_callbacks:
            for callback in self.event_callbacks[event_type]:
                try:
                    callback()
                except Exception as e:
                    print(f"Fehler bei Callback-Ausführung: {e}")
```

### Verwendung in Hardware-Interfaces
Die Hardware-Interface-Implementierungen verwenden das physikalische Modell über den `QuantumSimulatorState`:

```python
class MicrowaveSimulator:
    """Implementierung des Qudi MicrowaveInterface für die NV-Simulation."""
    
    def __init__(self):
        """Initialisierung des Mikrowellensimulators."""
        self._simulator_state = QuantumSimulatorState()
        
        # Mikrowellenparameter
        self._frequency = 2.87e9  # Hz
        self._power = -20.0  # dBm
        self._mode = 'cw'  # continuous wave
        self._scan_parameters = {}
        
        # Status
        self._is_running = False
    
    def on(self):
        """Schaltet die Mikrowellenquelle ein."""
        self._simulator_state.set_microwave_params(on=True)
        self._is_running = True
        return 0
    
    def off(self):
        """Schaltet die Mikrowellenquelle aus."""
        self._simulator_state.set_microwave_params(on=False)
        self._is_running = False
        return 0
    
    def get_status(self):
        """Gibt den Status der Mikrowellenquelle zurück."""
        return {'running': self._is_running, 'mode': self._mode}
    
    def set_cw(self, frequency=None, power=None):
        """Setzt die Parameter für Dauerstrichmodus."""
        if frequency is not None:
            self._frequency = frequency
        if power is not None:
            self._power = power
        
        self._mode = 'cw'
        self._simulator_state.set_microwave_params(
            frequency=self._frequency, 
            power=self._power
        )
        return 0
    
    def set_frequency(self, frequency):
        """Setzt die Mikrowellenfrequenz."""
        self._frequency = frequency
        self._simulator_state.set_microwave_params(frequency=frequency)
        return 0
    
    def get_frequency(self):
        """Gibt die aktuelle Mikrowellenfrequenz zurück."""
        return self._frequency
    
    def set_power(self, power):
        """Setzt die Mikrowellenleistung."""
        self._power = power
        self._simulator_state.set_microwave_params(power=power)
        return 0
    
    def get_power(self):
        """Gibt die aktuelle Mikrowellenleistung zurück."""
        return self._power
```

## Limitierungen und Annahmen

### Physikalische Limitierungen
Das implementierte Modell beinhaltet die folgenden Vereinfachungen und Annahmen:

1. **Näherungen im Hamiltonoperator**:
   - Vernachlässigung höherer Ordnungen der Spin-Spin-Wechselwirkung
   - Vereinfachte Behandlung der Hyperfeinwechselwirkung
   - Idealisiertes Mikrowellenfeld (homogen, monochromatisch)

2. **Umgebungseffekte**:
   - Phänomenologische Behandlung von Relaxation und Dekohärenz
   - Vereinfachte Temperaturabhängigkeit
   - Keine explizite Modellierung von Oberflächeneffekten oder Spannungen

3. **Numerische Grenzen**:
   - Endliche Zeitauflösung der Simulation
   - Trunkierungen in der Liouville-Entwicklung
   - Beschränkter Hilbertraum bei der Einbeziehung von Kernspins

### Modellerweiterungen
Zukünftige Versionen des Modells könnten folgende Erweiterungen beinhalten:

1. **Erweiterte Physik**:
   - Volle Behandlung der Kernspindynamik
   - Einbeziehung benachbarter 13C-Kernspins
   - Realistischere Behandlung optischer Übergänge

2. **Verbesserte Numerik**:
   - Adaptive numerische Verfahren für höhere Genauigkeit
   - GPU-Beschleunigung für komplexere Systeme
   - Quantum Trajectory-Methoden für effizientere stochastische Simulationen

## Verwandte Dokumente
- [Architekturübersicht](/Planung/Dokumente/3_Architektur/3.1_Architekturübersicht.md)
- [Funktionale Anforderungen](/Planung/Dokumente/2_Anforderungen/2.1_Funktionale_Anforderungen.md)
- [SimOS-Integration](/Planung/Dokumente/4_Technische_Konzepte/4.2_SimOS_Integration.md)
- [Qudi-Schnittstellen-Implementierung](/Planung/Dokumente/4_Technische_Konzepte/4.3_Qudi_Interfaces.md)

## Glossar
| Begriff | Definition |
|---------|------------|
| NV-Zentrum | Defekt im Diamantgitter, bestehend aus einem Stickstoffatom und einer benachbarten Fehlstelle |
| ODMR | Optically Detected Magnetic Resonance - Verfahren zur optischen Detektion magnetischer Resonanz |
| Rabi-Oszillation | Kohärente Oszillation eines Quantensystems zwischen zwei Zuständen unter resonanter Anregung |
| Liouville-von Neumann-Gleichung | Differentialgleichung für die Zeitentwicklung der Dichtematrix eines Quantensystems |
| Lindblad-Mastergleichung | Erweiterung der Liouville-von Neumann-Gleichung für offene Quantensysteme mit Dissipation |
| Zeeman-Effekt | Aufspaltung von Energieniveaus in einem externen Magnetfeld |
| T1-Relaxation | Longitudinale oder Spin-Gitter-Relaxation, charakterisiert den Energieaustausch mit der Umgebung |
| T2-Relaxation | Transversale oder Spin-Spin-Relaxation, charakterisiert den Verlust der Phasenkohärenz |
| SimOS | Python-Bibliothek zur Simulation optisch adressierbarer Spins |